## 1. Spring 프레임워크 개요

### 💡 애플리케이션 아키텍처의 발전

- 기본 웹 애플리케이션 → 웹 서비스 → REST API → 풀 스택 애플리케이션 → **마이크로서비스**
    
- 현재 대부분의 애플리케이션은 **클라우드 환경**에서 배포됨
    
- 다양한 **프레임워크**를 활용하여 애플리케이션 구축:
    
    - **Spring, Spring Boot**
        
    - **Spring MVC, Hibernate, Spring Security, Spring Data, Spring Cloud** 등
        

### 🧠 가장 중요한 두 가지 프레임워크

1. **Spring 프레임워크**
    
    - 유지보수하기 쉬운 애플리케이션 구축을 위한 핵심 기능 제공
        
    - **의존성 주입(DI, Dependency Injection)** 및 **자동 연결(Auto Wiring)**
        
2. **Spring Boot**
    
    - Spring 프레임워크를 쉽게 사용할 수 있도록 지원
        
    - 기존 Spring 기반 애플리케이션의 설정 부담을 대폭 줄임  
        🔹 설정 코드 줄이기:
        
        - 전통적인 Java 애플리케이션 → **1,000줄**
            
        - Spring 프레임워크 적용 → **700줄**
            
        - Spring Boot 사용 → **400줄**
            
    - **생산성을 극대화**하여 적은 코드로 더 많은 기능 구현 가능
        

### 🔍 Spring 프레임워크의 핵심 개념

초보자가 이해하기 어려운 주요 개념:

- **강한 결합(Strong Coupling) vs. 느슨한 결합(Loose Coupling)**
    
- **의존성 주입(DI, Dependency Injection)**
    
- **IOC 컨테이너(Inversion of Control Container)**
    
- **애플리케이션 컨텍스트(Application Context)**
    
- **Spring Bean**
    
- **자동 연결(Auto Wiring)**
    
- **컴포넌트 스캔(Component Scan)**
    
---
## 2.  💡 강한 결합(Strong Coupling) vs. 느슨한 결합(Loose Coupling)

### 🔍 강한 결합(Strong Coupling)이란?

- **한 클래스가 특정 클래스에 직접 의존하는 경우** 강한 결합이 발생
    
- 예제: `GameRunner` 클래스가 `MarioGame`과 직접 연결됨
    
    ```java
    public class GameRunner {
        private MarioGame game;
        
        public GameRunner(MarioGame game) {
            this.game = game;
        }
        
        public void run() {
            game.up();
            game.down();
            game.left();
            game.right();
        }
    }
    ```
    
- `MarioGame`을 `SuperContraGame`으로 변경하려면 `GameRunner` 코드를 수정해야 함
    
    ```java
    private SuperContraGame game;
    public GameRunner(SuperContraGame game) { this.game = game; }
    ```
    
- **문제점:** 새로운 게임이 추가될 때마다 `GameRunner`를 수정해야 하므로 유지보수성이 낮음
    

### 🎮 예제: 강한 결합의 문제

- `MarioGame`과 `SuperContraGame`의 동작 방식이 다름  
    → `GameRunner`가 특정 게임 클래스와 강하게 결합됨  
    → 게임을 변경할 때마다 `GameRunner` 코드 수정이 필요
    

### 🛠 강한 결합을 줄이려면?

- **느슨한 결합(Loose Coupling)을 사용**
    
- **Java 인터페이스**를 활용하여 특정 구현체가 아닌 **추상화된 인터페이스**에 의존하도록 변경
    
- **Spring 프레임워크**의 **의존성 주입(DI, Dependency Injection)** 을 활용하면 더욱 쉽게 해결 가능
    
---
## 3.  🎮 느슨한 결합을 위한 인터페이스 도입

### 💡 강한 결합에서 느슨한 결합으로 전환

이전 단계에서는 `GameRunner` 클래스가 특정 게임(`MarioGame`, `SuperContraGame`)과 **강하게 결합(Strong Coupling)** 되어 있었습니다.  
이번 단계에서는 **인터페이스**를 활용하여 **느슨한 결합(Loose Coupling)** 을 구현합니다.

---

### 🏗 GamingConsole 인터페이스 생성

모든 게임(`MarioGame`, `SuperContraGame`, `PacmanGame`)이 공통적으로 수행하는 동작을 **인터페이스**로 추상화합니다.

#### ✅ `GamingConsole` 인터페이스 정의

```java
public interface GamingConsole {
    void up();
    void down();
    void left();
    void right();
}
```

- `up()`, `down()`, `left()`, `right()` 메서드를 정의
    
- 게임 클래스들은 이 인터페이스를 **구현(implements)** 하게 됨
    

---

### 🎮 게임 클래스에서 인터페이스 구현

#### ✅ `MarioGame` 클래스

```java
public class MarioGame implements GamingConsole {
    public void up() { System.out.println("Jump"); }
    public void down() { System.out.println("Go into a pipe"); }
    public void left() { System.out.println("Move back"); }
    public void right() { System.out.println("Accelerate"); }
}
```

#### ✅ `SuperContraGame` 클래스

```java
public class SuperContraGame implements GamingConsole {
    public void up() { System.out.println("Go up"); }
    public void down() { System.out.println("Crouch"); }
    public void left() { System.out.println("Go back"); }
    public void right() { System.out.println("Shoot a bullet"); }
}
```

#### ✅ `PacmanGame` 클래스

```java
public class PacmanGame implements GamingConsole {
    public void up() { System.out.println("Move up"); }
    public void down() { System.out.println("Move down"); }
    public void left() { System.out.println("Move left"); }
    public void right() { System.out.println("Move right"); }
}
```

모든 게임이 `GamingConsole`을 **구현**하므로, 공통된 인터페이스를 통해 일관된 방식으로 동작할 수 있음.

---

### 🚀 `GameRunner` 클래스 수정 (느슨한 결합 적용)

이제 `GameRunner`는 특정 게임 클래스가 아닌 **인터페이스**에 의존하도록 변경됩니다.

#### ✅ `GameRunner` 클래스

```java
public class GameRunner {
    private GamingConsole game;

    public GameRunner(GamingConsole game) {  // 특정 게임 대신 인터페이스 사용
        this.game = game;
    }

    public void run() {
        game.up();
        game.down();
        game.left();
        game.right();
    }
}
```

- `GameRunner`가 특정 게임(`MarioGame`이나 `SuperContraGame`)과 **강하게 결합되지 않음**
    
- 대신 `GamingConsole` 인터페이스에 의존 → **게임을 바꿔도 `GameRunner` 코드 변경 불필요!**
    

---

### 🎯 게임 실행 (GameRunner가 특정 게임과 분리됨)

#### ✅ `AppGamingBasicJava` (메인 클래스)

```java
public class AppGamingBasicJava {
    public static void main(String[] args) {
        // 게임 변경이 용이함 (느슨한 결합)
        GamingConsole game = new MarioGame(); // MarioGame 실행
        // GamingConsole game = new SuperContraGame(); // SuperContraGame 실행
        // GamingConsole game = new PacmanGame(); // PacmanGame 실행

        GameRunner gameRunner = new GameRunner(game);
        gameRunner.run();
    }
}
```

- `MarioGame`, `SuperContraGame`, `PacmanGame`을 **선택적으로 실행 가능**
    
- `GameRunner` 클래스는 변경할 필요 없음 (느슨한 결합)
    
- **새로운 게임을 추가해도 `GamingConsole`만 구현하면 바로 사용 가능!**
    

---

### 🎯 느슨한 결합의 이점

✅ **유지보수 용이**: 새로운 게임 추가 시 `GameRunner` 코드 수정 불필요  
✅ **확장성 증가**: 인터페이스를 구현하는 클래스만 추가하면 다양한 게임 실행 가능  
✅ **유연성 향상**: 인터페이스를 통해 코드가 **더 유연하고 변경에 강함**

---

### 🔥 연습: `PacmanGame` 추가 및 실행

1. `PacmanGame`을 `GamingConsole` 인터페이스를 구현하도록 작성
    
2. `AppGamingBasicJava`에서 `game = new PacmanGame();`로 변경 후 실행
    
3. **결과 확인**: `"Move up"`, `"Move down"`, `"Move left"`, `"Move right"` 출력됨
    

---

### 🎩 다음 단계: **Spring 프레임워크를 활용한 느슨한 결합**

- **Spring 프레임워크**의 **의존성 주입(DI, Dependency Injection)** 을 활용하면 더 쉽게 느슨한 결합을 구현할 수 있음
    
- **수동 객체 생성 없이 Spring이 자동으로 게임을 실행하는 방식**을 배울 예정
    

🚀 **다음 단계에서 Spring의 마법을 경험해 봅시다!**