# 기술문서 심층 분석 요청 - 개선된 프롬프트


```markdown
# 역할 및 맥락

너는 시니어 풀스택 개발자이자 기술 아키텍트 역할로, 이 프로젝트의 모든 개발문서
(PRD, Architecture, UI/UX, Stories 등)를 **교차 검증(cross-reference)** 하면서
심층 기술 감사(Technical Audit)를 수행해야 한다.

이 문서들은 **Claude Code에 전달하여 실제 개발을 진행할 문서**이므로,
Claude Code가 개발 시 마주칠 수 있는 기술적 리스크를 사전에 식별하는 것이 핵심 목적이다.

**이 프로젝트는 "claude code 권장 AI 코드 생성 아키텍처 가이드"를 기반으로 하며**, 다음 원칙이 모든
분석의 기준이 된다:
- 3-Layer 분리 (클라이언트 → 서버 → 데이터)
- "서버 중심 + DB 무결성/원자성 활용 + 역할 분리" 철학
- RLS/RPC/View/Trigger의 목적 기반 사용 원칙
- 아키텍처 가이드의 금지 규칙과 권장 규칙

분석 시 **아키텍처 가이드의 원칙이 다른 문서(PRD, Stories, UI/UX)에서 제대로 반영되었는지**를
교차 검증하는 것이 핵심이다.

---

# 분석 수행 규칙

1. **모든 분석 항목에 심각도 등급을 부여**할 것:
   - 🔴 **CRITICAL**: 배포 불가 또는 서비스 장애 유발. 즉시 수정 필요
   - 🟡 **WARNING**: 기능은 작동하나 성능/보안/유지보수에 문제. 개발 중 수정 권장
   - 🔵 **INFO**: 개선하면 좋으나 필수는 아님. 백로그 등록 추천

2. **각 이슈에는 반드시 다음을 포함**할 것:
   - 이슈 설명 (무엇이 문제인가)
   - 근거 (왜 문제인가 - 공식문서, 벤치마크, 호환성 매트릭스 등 참조)
   - 영향 범위 (어떤 기능/문서/컴포넌트에 영향을 미치는가)
   - 권장 수정 방안 (구체적인 코드/설정 변경 포함)

3. **문서 간 불일치를 반드시 검출**할 것:
   - PRD에 명시된 기능이 Architecture에 반영되지 않은 경우
   - Architecture의 기술스택이 Stories의 구현 요구사항과 맞지 않는 경우
   - UI/UX 설계가 기술적으로 구현 불가능하거나 비효율적인 경우

---

# 분석 섹션 (아래 순서대로 분석)

## 섹션 1: 기술스택 감사 (Tech Stack Audit)

### 1-1. 버전 현황 및 최신성 검증
- 프로젝트에 명시된 모든 기술의 **현재 버전 vs 문서 명시 버전** 비교표 작성
- 각 기술의 **LTS/Stable 최신 버전** 기준으로 판단 (latest가 아닌 stable 기준)
- 버전이 오래된 경우: EOL(End of Life) 여부, 보안 패치 지원 여부 명시
- **출력 형식**: 비교 테이블

| 기술 | 문서 명시 버전 | 현재 Stable/LTS | 차이 | 심각도 | 비고 |
|------|--------------|----------------|------|--------|------|

### 1-2. 기술스택 간 호환성 매트릭스
- 주요 기술 간 **공식 호환성** 확인 (예: Next.js 16 + React 19, Drizzle + PostgreSQL 버전 등)
- **알려진 호환성 이슈** 나열 (GitHub Issues, 공식 Changelog 기반)
- **peer dependency 충돌** 가능성 분석

### 1-3. 대안 기술스택 비교
- 현재 스택의 각 기술에 대해 **더 적합한 대안**이 있는지 평가
- 프로젝트 요구사항(PRD 기반)과의 적합성 비교
- **출력 형식**: 비교 테이블 (현재 선택 vs 대안 1~2개, 장단점)

---

## 섹션 2: 아키텍처 분석 (Architecture Review)

### 2-1. 아키텍처 설계 문제점
- 확장성(Scalability) 병목 지점
- 단일 장애점(Single Point of Failure)
- 데이터 흐름의 비효율성
- 보안 취약점 (인증/인가 흐름, API 보안 등)

### 2-2. 프로덕션 환경 리스크
- 환경 변수/시크릿 관리 방식
- 로깅, 모니터링, 에러 핸들링 전략
- 데이터베이스 마이그레이션 전략
- 캐싱 전략 유무 및 적절성
- Rate Limiting, DDoS 방어

### 2-3. 배포 파이프라인 분석
- CI/CD 파이프라인 정의 유무 및 완성도
- 환경별(dev/staging/production) 분리 전략
- 롤백 전략
- 블루-그린 또는 카나리 배포 지원 여부

---

## 섹션 3: 코드 품질 분석 (Code Quality Review)

- 코드/스키마 정의에서 발견되는 **안티패턴**
- 타입 안전성(Type Safety) 이슈
- 에러 처리 패턴의 일관성
- 테스트 전략 유무 (단위/통합/E2E)
- 코드 구조가 Claude Code의 자동 생성에 적합한지 여부

---

## 섹션 4: UI/UX 기술 구현성 분석

- UI/UX 문서의 디자인이 현재 기술스택으로 **효율적으로 구현 가능한지** 평가
- 반응형(Responsive) 설계의 완성도
- 접근성(a11y) 준수 여부
- 성능 최적화 고려 (이미지 최적화, 레이지 로딩, 코드 스플리팅 등)
- 국제화(i18n) 지원 설계 유무

---

## 섹션 5: 확장성 및 유지보수성 심층 분석 (Maintainability & Scalability Deep Dive)

> Claude Code로 실제 개발을 진행할 예정이므로, 아래 항목을 빠짐없이 검사할 것.

### 5-1. 레이어 분리 원칙 준수 검증
아키텍처 가이드에서 정의한 3-Layer 구조가 모든 문서에서 일관되게 지켜지는지 검증:

- **Layer 1(클라이언트) → Layer 2(서버) → Layer 3(데이터)** 경계가 명확한가?
- 클라이언트에서 서버를 우회하여 데이터 레이어에 직접 접근하는 패턴이 없는가?
- 시크릿 키가 필요한 로직이 100% 서버 레이어에만 존재하는가?
- "비즈니스 로직의 중심은 서버 TypeScript"라는 원칙이 Stories/코드에 반영되어 있는가?
- **출력 형식**: 각 기능별 레이어 흐름도 (Client → Server → DB) + 위반 사례 테이블

### 5-2. Supabase 데이터 레이어 역할 분리 검증
아키텍처 가이드의 원칙이 실제 스키마/설계에 올바르게 반영되었는지:

- **RLS 정책**: 모든 테이블에 적용되어 있는가? 누락된 테이블 목록
- **RPC(Function) vs View**: 쓰기는 RPC, 읽기는 View로 분리되어 있는가? 혼용 사례
- **Trigger 사용 범위**: 감사 로그/타임스탬프/동기화 외 목적의 트리거가 있는가?
- **View 보안**: `security_invoker` 설정이 필요한 View에 적용되어 있는가?
- **제약조건**: UNIQUE/CHECK/FK가 데이터 무결성을 충분히 보장하는가?
- 도메인 로직이 SQL 함수에만 숨겨져 있는 안티패턴은 없는가?

### 5-3. 듀얼 스택(Expo + Next.js) 코드 공유 및 분기 전략 (이 부분은 듀얼스택에 해당할때만)
- Expo와 Next.js 간 **공유 가능한 코드**(types, validators, utils)의 분리 전략이 있는가?
- 플랫폼별 분기가 필요한 코드(네비게이션, 스토리지, 푸시알림 등)의 처리 방식
- **monorepo 전략** (turborepo/nx 등) 정의 유무 및 적절성
- 공유 패키지의 버전 관리 및 빌드 의존성 문제
- Expo API Routes ↔ Next.js Route Handler 간 로직 중복 여부

### 5-4. 새 기능 추가 시 확장성 시뮬레이션
- 각 시나리오에서 **수정이 필요한 레이어와 예상 변경 범위**를 명시

### 5-5. Claude Code 생성 적합성 분석
이 문서들을 Claude Code에 전달했을 때 발생할 수 있는 문제:

- 아키텍처 가이드의 **패턴 선택 기준**이 충분히 구체적인가?
  (Claude Code가 모호함 없이 올바른 패턴을 선택할 수 있는가?)
- **금지 규칙**과 **권장 규칙**이 코드 생성 시 자동으로 위반되기 쉬운 항목은?
- Stories에서 구현 방법이 명시되지 않아 Claude Code가 **잘못된 패턴을 추론**할 가능성이 있는 기능
- 타입 정의, 스키마, API 스펙이 충분히 명시되어 있어 Claude Code가 **일관된 코드**를 생성할 수 있는가?
- **출력 형식**: Claude Code 위험도 매트릭스

| 기능/Stories | Claude Code 잘못된 추론 위험도 | 원인 | 권장 보완 사항 |
|-------------|---------------------------|------|--------------|

### 5-6. 서드파티 의존성 및 Supabase 종속도 분석
- Supabase에 대한 **벤더 종속(vendor lock-in)** 수준 평가
  - Auth, Realtime, Storage, Edge Functions 중 대체 불가능한 항목
  - Supabase 서비스 장애 시 **fallback 전략** 유무
- TanStack Query, Zustand 등 상태 관리 라이브러리의 장기 유지보수 전망
- 사용 중인 모든 서드파티의 **라이선스 호환성** (MIT/Apache/GPL 등)
- API 버전 관리 전략 (v1/v2 병행 운용 가능한 구조인가?)

### 5-7. 모듈화 및 결합도 분석
- **repositories 패턴**(Layer 1)이 실제로 Supabase 구현을 캡슐화하는가?
  (나중에 Supabase를 다른 백엔드로 교체할 때 repositories만 수정하면 되는가?)
- hooks → repositories → supabase 간 **의존성 방향**이 단방향인가?
- 컴포넌트 간 순환 참조 가능성
- **관심사 분리(SoC)** 위반 사례 목록

---

## 섹션 6: 문서 간 교차 검증 결과 (Cross-Reference Findings)

- PRD ↔ Architecture 불일치 목록
- Architecture ↔ Stories 불일치 목록
- Stories ↔ UI/UX 불일치 목록
- **누락된 기능/요구사항** 목록

---

## 섹션 7: 아키텍처 가이드 준수도 체크 (Architecture Guide Compliance)

아키텍처 가이드에 정의된 원칙 대비, 다른 모든 문서의 준수 여부를 점검:

### 7-1. 금지 규칙 위반 검사
| 금지 규칙 | 위반 여부 | 위반 위치(문서/섹션) | 구체적 내용 |
|----------|----------|-------------------|-----------|

5가지 금지 규칙 각각에 대해 모든 문서를 스캔하여 위반 사례를 테이블로 정리

### 7-2. 권장 규칙 반영 검사
| 권장 규칙 | 반영 여부 | 미반영 시 리스크 | 보완 방안 |
|----------|----------|---------------|----------|

6가지 권장 규칙 각각에 대해 실제 반영 수준을 평가

### 7-3. 패턴 선택 기준 일관성 검사
Stories 또는 구현 명세에서 정의된 각 기능이 **6단계 체크리스트**를 올바르게 통과하는지:
- 시크릿 필요 로직이 클라이언트에 배치된 경우
- 원자 처리가 필요한데 RPC 대신 클라이언트 멀티 요청으로 처리하는 경우
- 단순 조회인데 View 대신 복잡한 서버 로직으로 처리하는 경우
- 각 위반/비효율 사례를 기능명과 함께 나열

---

## 섹션 8: 종합 권장사항 (Executive Summary)

- **즉시 수정 필요 항목** (🔴 CRITICAL 모아보기)
- **개발 전 수정 권장 항목** (🟡 WARNING 모아보기)
- **우선순위 기반 액션 플랜** (수정 순서 및 예상 소요 시간)
- **전체 기술 건강도 점수** (100점 만점)

---

# 출력 형식

- **파일 형식**: Markdown (.md)
- **각 섹션은 접기(collapsible) 가능하도록** `<details>` 태그 사용
- **모든 비교는 테이블 형식** 사용
- **코드 수정이 필요한 경우** before/after 코드 블록 포함
- **외부 참조(공식문서 URL 등)** 가능한 한 포함
```

---

## 프롬프트 개선 포인트 요약

### 구조적 개선

- **역할 지정**: "시니어 풀스택 개발자이자 기술 아키텍트"로 역할을 명확히 정의하여 분석 깊이를 강제
- **맥락 설명**: "Claude Code에 전달할 문서"라는 목적을 명시하여 분석 방향성 확보
- **섹션 분리**: 10개 이상의 나열 항목을 7개 대섹션 + 하위 항목으로 체계화

### 분석 품질 개선

- **심각도 등급**: 🔴🟡🔵 3단계로 이슈 우선순위 즉시 파악 가능
- **이슈 구조화**: 설명→근거→영향→수정방안 4단계 구조 강제
- **교차 검증**: 문서 간 불일치를 독립 섹션으로 분리하여 누락 방지
- **버전 기준 명확화**: "latest"가 아닌 "LTS/Stable" 기준으로 판단 기준 구체화

### 실행력 개선

- **출력 형식 지정**: 비교 테이블, before/after 코드 블록, `<details>` 태그 등 구체적 포맷 요구
- **액션 플랜 포함**: 이슈 발견에 그치지 않고 수정 순서와 예상 소요 시간까지 요청
- **건강도 점수**: 전체 프로젝트의 기술 성숙도를 한눈에 파악 가능

### 유지보수/확장성 심층 강화 (v2 추가)

- **레이어 분리 검증**: 아키텍처 가이드의 3-Layer 원칙이 모든 문서에서 일관되는지 교차 검증
- **Supabase 역할 분리**: RLS/RPC/View/Trigger 각각의 용도가 가이드 원칙(§3.1~3.4)대로 사용되는지 검증
- **듀얼 스택 전략**: Expo + Next.js 간 코드 공유/분기 전략의 존재 여부와 적절성 평가
- **확장 시뮬레이션**: 실시간 채팅, 결제, AI/ML, i18n, 멀티테넌시 5가지 시나리오로 확장성 스트레스 테스트
- **Claude Code 적합성**: 문서가 Claude Code에 전달되었을 때 잘못된 패턴을 생성할 위험도를 기능별로 매핑
- **벤더 종속도**: Supabase 종속 수준 및 fallback 전략 존재 여부 평가
- **결합도 분석**: repositories 패턴의 실제 캡슐화 수준 및 의존성 방향 검증

---

## 사용법

1. 위의 **개선된 프롬프트**를 복사
2. 프로젝트의 개발문서(PRD, Architecture, UI/UX, Stories 등)와 함께 Claude에 전달
3. Claude가 모든 문서를 교차 분석하여 구조화된 감사 보고서를 생성