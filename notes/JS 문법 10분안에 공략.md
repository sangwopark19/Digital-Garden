```js
// 한 줄 주석은 두 개의 슬래시로 시작합니다.
/* 여러 줄 주석은 슬래시-별표로 시작하고,
   별표-슬래시로 끝납니다 */

// 문장은 세미콜론으로 끝낼 수 있습니다
doStuff();

// ... 하지만 반드시 그럴 필요는 없습니다. 세미콜론은 특정 경우를 제외하고
// 줄바꿈이 있는 곳에 자동으로 삽입됩니다.
doStuff()

// 그런 특정 경우들이 예상치 못한 결과를 초래할 수 있기 때문에,
// 이 가이드에서는 계속 세미콜론을 사용하겠습니다.

///////////////////////////////////
// 1. 숫자, 문자열 및 연산자

// JavaScript는 하나의 숫자 타입(64비트 IEEE 754 double)을 가집니다.
// Double은 52비트 가수를 가지며, 이는 약 9✕10¹⁵까지의 정수를 정확하게 저장하기에 충분합니다.
3; // = 3
1.5; // = 1.5

// 기본적인 산술 연산은 예상대로 작동합니다.
1 + 1; // = 2
0.1 + 0.2; // = 0.30000000000000004
8 - 1; // = 7
10 * 2; // = 20
35 / 5; // = 7

// 불균등한 나눗셈도 포함됩니다.
5 / 2; // = 2.5

// 그리고 모듈로 나눗셈도 있습니다.
10 % 2; // = 0
30 % 4; // = 2
18.5 % 7; // = 4.5

// 비트 연산도 작동합니다; 비트 연산을 수행할 때 float는
// 최대 32비트의 부호 있는 int로 변환됩니다.
1 << 2; // = 4

// 괄호를 사용하여 연산 우선순위를 강제할 수 있습니다.
(1 + 3) * 2; // = 8

// 세 가지 특별한 숫자가 아닌 값이 있습니다:
Infinity; // 예를 들어 1/0의 결과
-Infinity; // 예를 들어 -1/0의 결과
NaN; // 예를 들어 0/0의 결과, '숫자가 아님'을 의미합니다

// 불리언 타입도 있습니다.
true;
false;

// 문자열은 ' 또는 "로 생성됩니다.
'abc';
"Hello, world";

// 부정은 ! 기호를 사용합니다
!true; // = false
!false; // = true

// 동등성은 ===입니다
1 === 1; // = true
2 === 1; // = false

// 불일치는 !==입니다
1 !== 1; // = false
2 !== 1; // = true

// 더 많은 비교
1 < 10; // = true
1 > 10; // = false
2 <= 2; // = true
2 >= 2; // = true

// 문자열은 +로 연결됩니다
"Hello " + "world!"; // = "Hello world!"

// ... 이는 문자열 뿐만 아니라 다른 것들과도 작동합니다
"1, 2, " + 3; // = "1, 2, 3"
"Hello " + ["world", "!"]; // = "Hello world,!"

// ...이는 때때로 이상한 동작을 초래할 수 있습니다...
13 + !0; // 14
"13" + !0; // '13true'

// 그리고 < 와 >로 비교됩니다
"a" < "b"; // = true

// 타입 강제 변환은 이중 등호로 비교할 때 수행됩니다...
"5" == 5; // = true
null == undefined; // = true

// ...===를 사용하지 않는 한
"5" === 5; // = false
null === undefined; // = false

// `charAt`을 사용하여 문자열의 문자에 접근할 수 있습니다
"This is a string".charAt(0);  // = 'T'

// ...또는 `substring`을 사용하여 더 큰 조각을 얻을 수 있습니다.
"Hello world".substring(0, 5); // = "Hello"

// `length`는 속성이므로 ()를 사용하지 않습니다.
"Hello".length; // = 5

// `null`과 `undefined`도 있습니다.
null;      // 의도적인 비값을 나타내는 데 사용됩니다
undefined; // 현재 값이 없음을 나타내는 데 사용됩니다 (비록
           // `undefined`도 그 자체로 값이지만)

// false, null, undefined, NaN, 0 및 ""는 거짓(falsy)입니다; 다른 모든 것은 참(truthy)입니다.
// 0은 거짓이고 "0"은 참이라는 점에 주의하세요, 비록 0 == "0"이지만요.

///////////////////////////////////
// 2. 변수, 배열 및 객체

// 변수는 `var` 키워드로 선언됩니다. JavaScript는 동적 타입이므로,
// 타입을 지정할 필요가 없습니다. 할당은 단일 `=` 문자를 사용합니다.
var someVar = 5;

// var 키워드를 생략하면 오류가 발생하지 않습니다...
someOtherVar = 10;

// ...하지만 변수가 선언된 범위가 아닌 전역 범위에서 생성됩니다.

// 값을 할당하지 않고 선언된 변수는 undefined로 설정됩니다.
var someThirdVar; // = undefined

// 몇 개의 변수를 선언하려면 쉼표 구분자를 사용할 수 있습니다
var someFourthVar = 2, someFifthVar = 4;

// 변수에 대한 수학 연산을 수행하는 단축 표현이 있습니다:
someVar += 5; // someVar = someVar + 5;와 동등합니다; someVar는 이제 10입니다
someVar *= 10; // 이제 someVar는 100입니다

// 1을 더하거나 빼는 더 짧은 표현도 있습니다
someVar++; // 이제 someVar는 101입니다
someVar--; // 다시 100으로 돌아갑니다

// 배열은 순서가 있는 값의 목록으로, 모든 타입이 가능합니다.
var myArray = ["Hello", 45, true];

// 배열의 멤버는 대괄호 첨자 구문을 사용하여 접근할 수 있습니다.
// 배열 인덱스는 0부터 시작합니다.
myArray[1]; // = 45

// 배열은 가변적이며 길이가 정해져 있지 않습니다.
myArray.push("World");
myArray.length; // = 4

// 특정 인덱스에 추가/수정
myArray[3] = "Hello";

// 배열의 앞이나 뒤에서 요소를 추가하고 제거합니다
myArray.unshift(3); // 첫 번째 요소로 추가
someVar = myArray.shift(); // 첫 번째 요소를 제거하고 반환
myArray.push(3); // 마지막 요소로 추가
someVar = myArray.pop(); // 마지막 요소를 제거하고 반환

// 배열의 모든 요소를 세미콜론으로 결합
var myArray0 = [32,false,"js",12,56,90];
myArray0.join(";"); // = "32;false;js;12;56;90"

// 인덱스 1(포함)부터 4(제외)까지의 하위 배열 얻기
myArray0.slice(1,4); // = [false,"js",12]

// 인덱스 2에서 시작하여 4개의 요소를 제거하고, 그 자리에 문자열
// "hi","wr", "ld"를 삽입합니다; 제거된 하위 배열 반환
myArray0.splice(2,4,"hi","wr","ld"); // = ["js",12,56,90]
// myArray0 === [32,false,"hi","wr","ld"]

// JavaScript의 객체는 다른 언어의 "사전" 또는 "맵"과 동등합니다:
// 순서가 없는 키-값 쌍의 모음입니다.
var myObj = {key1: "Hello", key2: "World"};

// 키는 문자열이지만, 유효한 JavaScript 식별자라면 따옴표가 필요 없습니다.
// 값은 어떤 타입이든 될 수 있습니다.
var myObj = {myKey: "myValue", "my other key": 4};

// 객체 속성은 대괄호 첨자 구문을 사용하여 접근할 수도 있습니다,
myObj["my other key"]; // = 4

// ... 또는 키가 유효한 식별자인 경우 점 구문을 사용할 수 있습니다.
myObj.myKey; // = "myValue"

// 객체는 가변적입니다; 값을 변경하고 새로운 키를 추가할 수 있습니다.
myObj.myThirdKey = true;

// 아직 설정되지 않은 값에 접근하려고 하면 undefined를 얻습니다.
myObj.myFourthKey; // = undefined

///////////////////////////////////
// 3. 논리와 제어 구조

// `if` 구조는 예상대로 작동합니다.
var count = 1;
if (count == 3){
    // count가 3일 때 평가됩니다
} else if (count == 4){
    // count가 4일 때 평가됩니다
} else {
    // 3도 4도 아닐 때 평가됩니다
}

// `while`도 마찬가지입니다.
while (true){
    // 무한 루프!
}

// do-while 루프는 while 루프와 비슷하지만, 항상 최소한 한 번은 실행됩니다.
var input;
do {
    input = getInput();
} while (!isValid(input));

// `for` 루프는 C와 Java와 같습니다:
// 초기화; 계속 조건; 반복.
for (var i = 0; i < 5; i++){
    // 5번 실행됩니다
}

// 레이블이 지정된 루프에서 빠져나오는 것은 Java와 유사합니다
outer:
for (var i = 0; i < 10; i++) {
    for (var j = 0; j < 10; j++) {
        if (i == 5 && j ==5) {
            break outer;
            // 내부 루프가 아닌 외부 루프에서 빠져나옵니다
        }
    }
}

// for/in 문은 객체의 속성을 반복할 수 있게 해줍니다.
var description = "";
var person = {fname:"Paul", lname:"Ken", age:18};
for (var x in person){
    description += person[x] + " ";
} // description = 'Paul Ken 18 '

// for/of 문은 반복 가능한 객체(내장 String, Array 등 Array-like 객체인 arguments나 NodeList,
// TypedArray, Map과 Set, 그리고 사용자 정의 반복 가능한 객체 포함)를 반복할 수 있게 해줍니다.
var myPets = "";
var pets = ["cat", "dog", "hamster", "hedgehog"];
for (var pet of pets){
    myPets += pet + " ";
} // myPets = 'cat dog hamster hedgehog '

// &&는 논리 AND, ||는 논리 OR입니다
if (house.size == "big" && house.colour == "blue"){
    house.contains = "bear";
}
if (colour == "red" || colour == "blue"){
    // colour는 빨간색이거나 파란색입니다
}

// &&와 ||는 "단락 평가"를 하며, 이는 기본값 설정에 유용합니다.
var name = otherName || "default";

// `switch` 문은 `===`로 동등성을 확인합니다.
// 각 case 후에 'break'를 사용하세요
// 그렇지 않으면 올바른 case 이후의 case들도 실행됩니다.
grade = 'B';
switch (grade) {
  case 'A':
    console.log("잘했어요");
    break;
  case 'B':
    console.log("괜찮아요");
    break;
  case 'C':
    console.log("더 잘할 수 있어요");
    break;
  default:
    console.log("어이쿠");
    break;
}


///////////////////////////////////
// 4. 함수, 스코프 및 클로저

// JavaScript 함수는 `function` 키워드로 선언
```