첫번째 단계 - api 파라미터 받고 리턴하는 방법

1.엔티티 노출하면 api스펙 변하니까 dto로 파라미터 받고 리턴하는거

2.json array로 리턴하면 안되니까 한번더 감싸서 리턴하는거

=> 안좋은 코드다

  

  

두번째 단계 - lazy로딩

jpa기본방식으로 쓰면 엔티티에 조인된 컬럼 다끌고오는데 이런방식으로 운영하면 망한다

엔티티의 필드에서 참조값이 꺼내어질때만 db에 따로 쿼리 날리는 lazy방식으로 바꿔야 함

엔티티 질의방식 lazy loading으로 바꿈

=>이런식으로 쓰면 성능향상이 확실히 체감 된다

  

  

세번째 단계 - fetch join

기본값인 eager처럼 한방에 

레퍼런스로 연결된 테이블들을 다같이 조인해서 질의하는건 미친짓이라서 

lazy로딩을 안쓸수는 없지만

lazy로딩을 쓰는것도 데이터에 따로 질의를 하면서 부하를 발생시킴

이부분에서 쿼리 최적화가 필요함

  

다대일 관계에서는 fetch join

일대다 관계에서는 collection fetch join을 사용하면 된다고 함

fetch join 이라는걸 사용하면 일대다가 포함된 경우 

조인된 컬럼을 레프트 조인으로 가져와서 한 api호출당 한방쿼리가 가능함

  

  

네번째 단계 - in절 넣어서 최적화 하기

fetch조인은 조인된 테이블들을 한방에 가져오는 장점이 있지만

일대다 관계에서 레프트 조인이되면 질의결과가 뻥튀기 되는 단점이 있어서

이 방법으로는 페이징을 할수도 없음 fetch join이 더 빠르고 궁극적인 방법이지만 

페이징이 필요한 경우에는 못씀

  

그래서 lazy로딩시에 참조값을 하나씩 가져오는 문제가 다시 발생하게 되고

이 방법을 해결하려면 

내가 조회하려는 정보의 주 테이블과 조인테이블을 하나씩 질의하는 것에서

조인 해야 하는 테이블의 인덱싱된 기본키를 인절에 넣어서 처리하면 페이징이 가능함

  

그래서 페이징이 필요한 경우에는 in절을 넣는 batchsize를 통해 해결하면 되고

페이징이 없는 경우에는 fetch join으로 한방에 가져오면 됨

  

  

실제로 배민에서 이방법으로 운영팀 기술지원을 해준적이 있는데

1시간 돌던 셀렉트 쿼리가 7분만에 돌았다고 함 ㅋㅋㅋ