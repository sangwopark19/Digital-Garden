# 컴포넌트 스캔
---
[[스프링 핵심 원리 - 기본편]]

## 목차
---

## 컴포넌트 스캔과 의존관계 자동 주입
---
- 기본적으로 스프링 빈 등록은 자바 코드의 `@Bean`이나 XML의 `<bean>`으로 설정 정보에 직접 등록할 스프링 빈을 나열했다.
- 하지만 실무에서 스프링 빈이 수십, 수백개가 되면 **귀찮고, 설정정보가 커지고, 누락되는 문제**가 발생한다
- 이를 해결하기위해 **컴포넌트 스캔**이라는 자동으로 스프링 빈을 등록하는 기능을 제공한다.
- 또 의존관계 자동주입을 위한 `@Autowired`라는 기능도 제공한다.

```java
@Configuration
 @ComponentScan(
// @Configuration이 달린 클래스는 제외하라는 필터
// 예제를 위해 작성한 것이고 실제로 개발을 할 때는
// @Configuration이 달린 설정파일도 같이 컴포넌트스캔한다.
         excludeFilters = @Filter(type = FilterType.ANNOTATION, classes =
 Configuration.class))

public class AutoAppConfig {
}
```

- 기존 AppConfig와는 다르게 `@Bean`으로 등록한 클래스가 하나도 없다.
- `@ComponentScan`이 있는 설정정보 클래스는 `@Component`가 있는 클래스를 자동으로 `@Bean`으로 등록해준다.
- 이 때 의존관계 주입에 대한 문제가 생기게 되는데 **`@Autowired`** 가 의존관계를 자동으로 주입해준다.
```java
 @Component public class OrderServiceImpl implements OrderService {

     private final MemberRepository memberRepository;
     private final DiscountPolicy discountPolicy;

@Autowired

     public OrderServiceImpl(MemberRepository memberRepository, DiscountPolicy
 discountPolicy) {

         this.memberRepository = memberRepository;

         this.discountPolicy = discountPolicy;
     }

}
```

- `AnnotationConfigApplicationContext`를 사용하는 것은 기존과 **동일**하다
- 설정 정보로 `@ComponentScan`이 달린 클래스를 넘겨준다.

### @ComponentScan
![[Pasted image 20231205130407.png]]
- `@ComponentScan`은 `@Component`가 붙은 **모든 클래스**를 스프링 빈으로 등로한다.
	- 이 떄 빈 이름은 기본적으로 **클래스명에서 맨 앞글자만 소문자**로 바꾼 이름을 사용한다
	- 빈 이름을 직접 지정하고싶으면 `@Component("memberService2")`처럼 이름을 부여하면된다 근데 디폴트가 좋다

### @Autowired 의존관계 자동 주입
![[Pasted image 20231205130658.png]]
- 생성자에 `@Autowired`를 사용하면 스프링 컨테이너가 자동으로 해당 스프링 빈을 찾아서 주입한다.
- 이 때 기본 조회 전략은 **타입이 같은 빈**을 찾아서 주입한다.
	- `getBean(MemberRepository.class)`와 동일하다