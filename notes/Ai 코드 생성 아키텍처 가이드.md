# AI 코드 생성 아키텍처 가이드

## 1. 개요

AI 코드 생성은 단순히 "프롬프트를 넣으면 코드가 나온다"는 수준을 넘어, 소프트웨어 엔지니어링의 전 과정을 재설계하는 패러다임 전환이다. 이 문서는 AI 코드 생성 시스템을 설계하고 운용할 때 고려해야 할 아키텍처적 원칙, 실무 패턴, 그리고 품질 보증 전략을 다룬다.

### 1.1 이 문서의 대상

- AI 에이전트(Claude Code, Cursor, Copilot 등)를 활용해 실제 프로덕션 코드를 생성하는 개발자
- AI 코드 생성 파이프라인을 팀이나 조직에 도입하려는 리드/아키텍트
- AI 코드 생성 도구 자체를 설계하거나 커스터마이징하려는 엔지니어

### 1.2 핵심 전제

AI 코드 생성의 품질은 **모델의 능력 × 컨텍스트의 정밀도 × 아키텍처적 제약 조건의 명확성**에 비례한다. 모델이 아무리 뛰어나도 컨텍스트가 불명확하거나 아키텍처 가이드라인이 없으면 결과물은 일관성 없는 스파게티 코드가 된다.

---

## 2. 기본 아키텍처: 코드 생성 파이프라인

AI 코드 생성은 선형적 과정이 아니라 순환적 파이프라인이다.

### 2.1 5단계 파이프라인 모델

```
[의도 정의] → [컨텍스트 조립] → [생성] → [검증] → [통합]
     ↑                                              |
     └──────────── 피드백 루프 ─────────────────────┘
```

**1단계: 의도 정의 (Intent Specification)**

사람의 요구사항을 AI가 이해할 수 있는 구조화된 명세로 변환하는 단계다. 여기서 핵심은 "무엇을 만들 것인가"와 "어떤 제약 조건 하에서 만들 것인가"를 분리하는 것이다.

```
의도 = {
  기능 요구사항: "사용자 인증 API 엔드포인트",
  기술 제약: "Next.js App Router, Supabase Auth, TypeScript strict mode",
  품질 제약: "에러 핸들링 포함, 엣지 케이스 처리, 테스트 코드 동반",
  스타일 제약: "프로젝트 기존 패턴 준수, ESLint 규칙 통과"
}
```

**2단계: 컨텍스트 조립 (Context Assembly)**

AI 모델의 컨텍스트 윈도우에 무엇을 넣을지 결정하는 단계다. 이 단계의 설계가 코드 생성 품질의 70%를 결정한다.

**3단계: 생성 (Generation)**

모델이 실제 코드를 출력하는 단계다. 단일 호출로 끝나는 경우도 있고, 멀티턴 대화를 통해 점진적으로 완성되는 경우도 있다.

**4단계: 검증 (Validation)**

생성된 코드가 의도에 부합하는지, 기술적으로 올바른지 확인하는 단계다. 자동화된 검증과 사람의 리뷰가 결합된다.

**5단계: 통합 (Integration)**

검증을 통과한 코드를 기존 코드베이스에 병합하는 단계다. Git 워크플로우, CI/CD 파이프라인과의 연동이 핵심이다.

### 2.2 피드백 루프의 설계

파이프라인의 각 단계에서 실패가 발생하면 이전 단계로 돌아가야 한다. 이때 중요한 것은 **실패 정보를 구조화해서 전달**하는 것이다.

```
피드백 = {
  실패_단계: "검증",
  실패_유형: "타입 에러",
  실패_상세: "Property 'userId' does not exist on type 'Session'",
  시도_횟수: 2,
  이전_시도_요약: ["Session 타입 직접 접근 → 실패", "getUser() 메서드 사용 → 부분 성공"]
}
```

단순히 "에러 났으니 고쳐줘"가 아니라, 구조화된 실패 정보를 제공하면 모델이 같은 실수를 반복할 확률이 크게 줄어든다.

---

## 3. 컨텍스트 엔지니어링

### 3.1 컨텍스트의 계층 구조

AI 코드 생성에서 컨텍스트는 단일 프롬프트가 아니라 계층적으로 구성된다.

```
┌─────────────────────────────────────────────┐
│  L0: 시스템 프롬프트 (불변)                    │
│  - 모델의 역할 정의                            │
│  - 전역 코딩 컨벤션                            │
│  - 보안/안전 가이드라인                         │
├─────────────────────────────────────────────┤
│  L1: 프로젝트 컨텍스트 (세션 단위)              │
│  - 기술 스택 정의                              │
│  - 아키텍처 패턴                               │
│  - 디렉토리 구조                               │
│  - 핵심 인터페이스/타입 정의                     │
├─────────────────────────────────────────────┤
│  L2: 태스크 컨텍스트 (작업 단위)                │
│  - 현재 수정 대상 파일                          │
│  - 관련 파일 (import/export 관계)              │
│  - 관련 테스트 파일                             │
│  - 최근 변경 이력                              │
├─────────────────────────────────────────────┤
│  L3: 즉시 컨텍스트 (턴 단위)                    │
│  - 현재 프롬프트                               │
│  - 직전 대화 히스토리                           │
│  - 에러 메시지/로그                             │
└─────────────────────────────────────────────┘
```

### 3.2 컨텍스트 윈도우 예산 관리

컨텍스트 윈도우는 유한한 자원이다. 모든 것을 넣을 수 없으므로, 토큰 예산을 전략적으로 배분해야 한다.

**예산 배분 원칙:**

|계층|권장 비율|역할|
|---|---|---|
|L0: 시스템 프롬프트|5-10%|일관성의 기반|
|L1: 프로젝트 컨텍스트|15-25%|아키텍처 정합성 보장|
|L2: 태스크 컨텍스트|40-50%|실제 코드 생성의 재료|
|L3: 즉시 컨텍스트|10-15%|현재 요청의 정밀도|
|출력 여유분|15-20%|생성 코드를 위한 공간|

**핵심 규칙:** 출력 여유분을 반드시 확보해야 한다. 컨텍스트를 너무 많이 넣으면 정작 생성할 코드의 공간이 부족해져 불완전한 코드가 출력된다.

### 3.3 컨텍스트 선택 전략

모든 파일을 컨텍스트에 넣을 수 없으므로, **관련성 기반 선택**이 필요하다.

**정적 분석 기반 선택:**

- import/export 그래프를 추적해서 직접 의존하는 파일만 포함
- 타입 정의 파일은 항상 포함 (인터페이스 일관성 보장)
- 유사한 기능을 구현한 기존 파일을 "참고 예시"로 포함

**의미적 유사도 기반 선택:**

- 코드베이스를 임베딩하고, 현재 태스크와 가장 유사한 코드 조각을 검색
- RAG(Retrieval-Augmented Generation) 패턴을 코드 생성에 적용

**하이브리드 접근:**

```
선택된_컨텍스트 = 
  정적_의존성(현재_파일) 
  ∪ 타입_정의(현재_모듈) 
  ∪ Top-K_유사_코드(현재_태스크, K=3)
  ∪ 관련_테스트(현재_파일)
```

---

## 4. 프로젝트 구조화 전략: AI 친화적 코드베이스

### 4.1 AI가 이해하기 쉬운 프로젝트 구조의 원칙

AI 모델은 패턴 인식에 강하다. 따라서 프로젝트 구조가 일관되고 예측 가능할수록 코드 생성 품질이 올라간다.

**원칙 1: 기능 단위 디렉토리 구조 (Feature-based)**

```
src/
├── features/
│   ├── auth/
│   │   ├── components/
│   │   ├── hooks/
│   │   ├── api/
│   │   ├── types.ts
│   │   └── index.ts
│   ├── chat/
│   │   ├── components/
│   │   ├── hooks/
│   │   ├── api/
│   │   ├── types.ts
│   │   └── index.ts
│   └── ...
├── shared/
│   ├── components/
│   ├── hooks/
│   ├── utils/
│   └── types/
└── infrastructure/
    ├── api-client/
    ├── database/
    └── config/
```

이 구조는 AI에게 명확한 경계를 제공한다. "auth 기능에 비밀번호 재설정 추가해줘"라고 하면, 모델은 `features/auth/` 내부만 집중적으로 보면 된다.

**원칙 2: 명시적 인터페이스 경계**

모듈 간 통신은 반드시 명시적 인터페이스를 통해야 한다. AI가 모듈 내부 구현에 직접 의존하는 코드를 생성하는 것을 방지한다.

```typescript
// features/auth/index.ts — 이 파일이 모듈의 공개 API
export { AuthProvider } from './components/AuthProvider';
export { useAuth } from './hooks/useAuth';
export { login, logout, resetPassword } from './api/authApi';
export type { User, Session, AuthState } from './types';
```

**원칙 3: 규칙 파일을 통한 컨벤션 명문화**

프로젝트 루트에 AI가 참조할 수 있는 규칙 파일을 둔다.

```
프로젝트 루트/
├── CLAUDE.md          # Claude Code용 프로젝트 지침
├── .cursorrules       # Cursor용 프로젝트 지침
├── ARCHITECTURE.md    # 아키텍처 의사결정 기록
├── CONVENTIONS.md     # 코딩 컨벤션 문서
└── ...
```

### 4.2 CLAUDE.md / 규칙 파일 설계 패턴

AI 에이전트가 프로젝트에 진입할 때 가장 먼저 읽는 파일이다. 이 파일의 설계가 전체 코드 생성의 일관성을 결정한다.

**효과적인 규칙 파일의 구조:**

```markdown
# 프로젝트: [프로젝트명]

## 기술 스택
- Runtime: Node.js 20+
- Framework: Next.js 14 (App Router)
- Language: TypeScript (strict mode)
- Database: Supabase (PostgreSQL)
- ORM: Drizzle
- Styling: Tailwind CSS
- State: Zustand
- Testing: Vitest + Playwright

## 아키텍처 원칙
1. Server Components를 기본으로 사용. Client Components는 상호작용이 필요한 경우에만.
2. 데이터 페칭은 Server Components에서 직접 수행. API Route는 외부 연동용으로만.
3. 모든 비즈니스 로직은 features/ 내에 격리.
4. shared/는 순수 유틸리티만. 비즈니스 로직 금지.

## 코딩 컨벤션
- 함수 컴포넌트만 사용 (class 컴포넌트 금지)
- named export 사용 (default export는 page.tsx만 허용)
- 에러 핸들링: 커스텀 에러 클래스 사용 (shared/errors/)
- 로깅: 구조화된 로깅 (shared/logger) 사용

## 금지 사항
- any 타입 사용 금지
- console.log 직접 사용 금지 (logger 사용)
- 인라인 스타일 금지
- 하드코딩된 문자열 금지 (i18n 키 사용)

## 파일 생성 시 체크리스트
- [ ] TypeScript strict 모드 통과
- [ ] 관련 테스트 파일 동반 생성
- [ ] index.ts에 export 추가
- [ ] 에러 핸들링 포함
```

### 4.3 타입 시스템을 통한 아키텍처 강제

TypeScript의 타입 시스템은 AI 코드 생성에서 가장 강력한 가드레일이다.

```typescript
// 브랜드 타입으로 도메인 개념을 명확히 구분
type UserId = string & { readonly __brand: 'UserId' };
type PostId = string & { readonly __brand: 'PostId' };

// AI가 UserId와 PostId를 혼동하는 것을 컴파일 타임에 방지
function getPost(postId: PostId): Promise<Post> { ... }
getPost(userId); // 컴파일 에러!

// 상태 머신을 타입으로 표현
type OrderState = 
  | { status: 'pending'; createdAt: Date }
  | { status: 'confirmed'; confirmedAt: Date; estimatedDelivery: Date }
  | { status: 'shipped'; trackingNumber: string }
  | { status: 'delivered'; deliveredAt: Date };

// AI가 잘못된 상태 전이를 생성하는 것을 방지
function confirmOrder(order: Extract<OrderState, { status: 'pending' }>): 
  Extract<OrderState, { status: 'confirmed' }> { ... }
```

---

## 5. 프롬프트 아키텍처

### 5.1 프롬프트 설계의 3원칙

**원칙 1: 분할 정복 (Decomposition)**

큰 작업을 작은 단위로 분해해서 요청한다. "전체 인증 시스템을 만들어줘"보다 아래가 낫다:

```
1단계: "User, Session 타입 정의를 만들어줘"
2단계: "이 타입을 기반으로 Supabase Auth 래퍼 함수를 만들어줘"  
3단계: "이 래퍼를 사용하는 useAuth 훅을 만들어줘"
4단계: "이 훅을 사용하는 LoginForm 컴포넌트를 만들어줘"
```

각 단계의 출력이 다음 단계의 컨텍스트가 되므로, 점진적으로 정밀도가 올라간다.

**원칙 2: 예시 주도 (Example-driven)**

추상적 설명보다 구체적 예시가 더 정확한 코드를 생성한다.

```
# 나쁜 프롬프트
"API 에러 핸들링을 잘 해줘"

# 좋은 프롬프트
"에러 핸들링은 다음 패턴을 따라줘:

// 기존 코드의 에러 핸들링 패턴
try {
  const result = await api.getData();
  return { success: true, data: result };
} catch (error) {
  if (error instanceof AuthError) {
    redirect('/login');
  }
  if (error instanceof ValidationError) {
    return { success: false, errors: error.details };
  }
  logger.error('Unexpected error', { error, context: 'getData' });
  throw new AppError('INTERNAL_ERROR', 'Something went wrong');
}

이 패턴과 동일한 방식으로 새로운 API 함수의 에러 핸들링을 구현해줘."
```

**원칙 3: 제약 우선 (Constraint-first)**

"무엇을 해야 하는가"보다 "무엇을 하면 안 되는가"를 먼저 명시한다. AI 모델은 제약 조건이 명확할수록 더 정확한 코드를 생성한다.

```
제약 조건:
- 외부 라이브러리 추가 금지 (기존 의존성만 사용)
- 동기 방식 금지 (모든 I/O는 async/await)
- 전역 상태 변경 금지
- 200줄 이하로 작성

이 제약 하에서 파일 업로드 기능을 구현해줘.
```

### 5.2 메타 프롬프팅: AI에게 생성 전략을 지시하기

단순히 "코드를 생성해줘"가 아니라, **어떻게 생성할지**를 지시하는 메타 프롬프트를 활용한다.

```
다음 순서로 작업해줘:
1. 먼저 전체 구조를 의사코드로 작성해줘 (구현 X)
2. 의사코드를 검토하고 수정할 부분이 있으면 알려줘
3. 승인하면 실제 TypeScript 코드로 변환해줘
4. 각 함수에 대한 단위 테스트를 작성해줘
5. 엣지 케이스를 3개 이상 식별하고 처리해줘
```

이 패턴은 AI가 한 번에 완성된 코드를 출력하려다 실수하는 것을 방지하고, 중간 검증 포인트를 제공한다.

### 5.3 GSD(Get Shit Done) 패턴과 메타 프롬프팅의 통합

GSD와 같은 메타 프롬프팅 시스템은 위의 원칙들을 자동화한다. 핵심 구조:

```
[프로젝트 초기화 질문] → [컨텍스트 수집] → [계획 수립] → [반복적 구현]
```

GSD의 강점은 "질문 단계"에 있다. 구현 전에 체계적인 질문을 통해 모호함을 제거하고, 수집된 답변이 이후 모든 코드 생성의 컨텍스트로 작용한다.

---

## 6. 멀티 에이전트 아키텍처

### 6.1 단일 에이전트의 한계

단일 AI 에이전트로 전체 개발 워크플로우를 처리하면 다음 문제가 발생한다:

- **컨텍스트 오염:** 디버깅 대화가 설계 컨텍스트를 밀어낸다
- **역할 충돌:** 아키텍트와 구현자의 관점이 혼재된다
- **피드백 부재:** 자기가 생성한 코드를 자기가 리뷰하면 편향이 발생한다

### 6.2 역할 분리 패턴

```
┌─────────────┐     ┌──────────────┐     ┌─────────────┐
│  아키텍트     │────→│  구현자       │────→│  리뷰어      │
│  에이전트     │     │  에이전트     │     │  에이전트     │
└─────────────┘     └──────────────┘     └─────────────┘
       │                    │                    │
       │    설계 문서        │    구현 코드         │    리뷰 결과
       │    인터페이스 정의   │    테스트 코드        │    개선 제안
       ↓                    ↓                    ↓
┌────────────────────────────────────────────────────┐
│              공유 컨텍스트 저장소                      │
│  (파일 시스템 / Git / 구조화된 문서)                   │
└────────────────────────────────────────────────────┘
```

**아키텍트 에이전트:**

- 시스템 프롬프트에 아키텍처 원칙과 디자인 패턴을 주입
- 입력: 요구사항 → 출력: 인터페이스 정의, 모듈 분해, 데이터 흐름도
- 구현 코드를 직접 생성하지 않음

**구현자 에이전트:**

- 시스템 프롬프트에 코딩 컨벤션과 프레임워크 지식을 주입
- 입력: 아키텍트의 설계 문서 + 기존 코드 → 출력: 구현 코드 + 테스트
- 설계 변경을 하지 않음 (설계에 문제가 있으면 아키텍트에게 리턴)

**리뷰어 에이전트:**

- 시스템 프롬프트에 코드 리뷰 체크리스트와 품질 기준을 주입
- 입력: 구현 코드 + 설계 문서 → 출력: 리뷰 결과 + 개선 제안
- 보안, 성능, 가독성, 테스트 커버리지를 독립적으로 평가

### 6.3 오케스트레이션 패턴

멀티 에이전트 시스템의 핵심은 에이전트 간 통신과 흐름 제어다.

**파이프라인 패턴:** 순차적 처리. 단순하지만 병목이 생길 수 있다.

```
아키텍트 → 구현자 → 리뷰어 → (수정 필요시) 구현자 → 리뷰어
```

**감독자 패턴:** 중앙 오케스트레이터가 작업을 분배하고 수집한다.

```
        ┌→ 프론트엔드 구현자 ─┐
오케스트레이터 ├→ 백엔드 구현자 ──┤→ 오케스트레이터 → 통합 리뷰
        └→ 테스트 작성자 ────┘
```

**블랙보드 패턴:** 공유 저장소에 각 에이전트가 비동기적으로 기여한다.

```
에이전트A ──┐         ┌── 에이전트A
에이전트B ──┼→ 블랙보드 ←┼── 에이전트B
에이전트C ──┘         └── 에이전트C
```

---

## 7. 코드 생성 품질 보증

### 7.1 다층 검증 시스템

AI가 생성한 코드를 프로덕션에 투입하기 전에 반드시 거쳐야 할 검증 계층이다.

```
L1: 구문 검증    — 파싱 가능한 코드인가?
L2: 타입 검증    — 타입 체크를 통과하는가? (tsc --noEmit)
L3: 린트 검증    — 코딩 컨벤션을 준수하는가? (ESLint, Prettier)
L4: 단위 테스트   — 개별 함수가 올바르게 동작하는가?
L5: 통합 테스트   — 모듈 간 상호작용이 올바른가?
L6: 의미 검증    — 원래 의도한 기능을 수행하는가?
L7: 보안 검증    — 보안 취약점이 없는가?
```

L1~L3은 완전 자동화가 가능하며, AI 코드 생성 파이프라인에 필수적으로 내장해야 한다. L4~L5는 AI가 테스트도 함께 생성하게 해서 반자동화할 수 있다. L6~L7은 사람의 판단이 필요한 영역이지만, AI 리뷰어 에이전트가 1차 필터 역할을 할 수 있다.

### 7.2 AI 생성 코드의 대표적 결함 패턴

AI 코드 생성에서 반복적으로 나타나는 결함 패턴을 인지하면 리뷰 효율이 올라간다.

**환각 API (Hallucinated API):** 존재하지 않는 라이브러리 함수나 API를 호출하는 코드를 생성한다. 특히 최신 프레임워크 버전에서 빈번하다.

대응: 생성 후 `import` 문을 자동으로 해석하고, 실제 존재하는 API인지 검증하는 단계를 추가한다.

**과잉 추상화 (Over-abstraction):** 불필요하게 복잡한 디자인 패턴을 적용한다. 단순한 함수 호출이면 충분한 곳에 Strategy 패턴 + Factory 패턴을 적용한다.

대응: "가장 단순한 방법으로 구현해줘. 추상화가 필요한 근거를 설명해줘" 같은 제약을 프롬프트에 추가한다.

**컨텍스트 드리프트 (Context Drift):** 긴 대화에서 초기 요구사항을 점차 잊어버리고, 최근 대화 내용에만 과도하게 반응한다.

대응: 주기적으로 원래 요구사항을 재주입하거나, 대화를 새로 시작하되 핵심 결정사항을 요약해서 전달한다.

**복사-변형 오류 (Copy-mutate Error):** 기존 코드를 참조해서 유사한 코드를 생성할 때, 변경해야 할 부분을 미변경하거나 잘못 변경한다. 변수명이나 엔드포인트 경로가 원본 그대로인 경우가 대표적이다.

대응: 생성된 코드에서 원본과의 diff를 검토하고, 변경되어야 할 부분이 모두 변경되었는지 체크리스트를 활용한다.

**낙관적 에러 핸들링 (Optimistic Error Handling):** happy path만 구현하고 에러 처리를 생략하거나, catch 블록에서 에러를 삼켜버린다.

대응: "모든 외부 호출에 대해 실패 시나리오를 명시적으로 처리해줘"를 표준 지시로 포함한다.

### 7.3 테스트 전략

AI 코드 생성과 테스트는 상호 보완적이다.

**테스트 우선 생성 (Test-first Generation):**

```
1. 먼저 테스트 케이스를 생성하게 한다
2. 테스트를 사람이 검토하고 승인한다
3. 승인된 테스트를 통과하는 구현 코드를 생성하게 한다
```

이 패턴의 장점: 테스트가 곧 명세서가 되어, AI의 구현 방향을 제한한다.

**속성 기반 테스트 (Property-based Testing):**

```typescript
// AI에게 속성을 정의하게 하면 엣지 케이스를 더 많이 커버한다
// 예: "어떤 입력에 대해서도 다음 속성이 항상 성립해야 한다"
// - serialize(deserialize(x)) === x
// - sort(sort(x)) === sort(x)
// - 결과의 길이는 항상 입력의 길이 이하
```

---

## 8. 보안 아키텍처

### 8.1 AI 생성 코드의 보안 위협 모델

AI가 생성한 코드가 가질 수 있는 보안 위험 영역:

**주입 취약점:** AI가 사용자 입력을 적절히 이스케이프하지 않는 코드를 생성할 수 있다. SQL 인젝션, XSS, 명령어 인젝션 등.

**비밀 정보 노출:** 하드코딩된 API 키, 데이터베이스 자격 증명, 시크릿을 포함한 코드를 생성할 수 있다.

**불안전한 기본값:** 암호화를 비활성화하거나, CORS를 전부 허용하거나, 인증을 건너뛰는 코드를 생성할 수 있다.

**의존성 혼동:** 존재하지 않는 패키지명을 import하는 코드를 생성하면, 공격자가 해당 이름으로 악성 패키지를 등록할 수 있다 (Dependency Confusion Attack).

### 8.2 보안 가드레일 설계

```
코드 생성 시 보안 규칙:

1. 모든 사용자 입력은 반드시 검증/이스케이프 후 사용
2. 비밀 정보는 반드시 환경 변수로 관리 (process.env.*)
3. 외부 URL은 반드시 허용 목록(allowlist)으로 제한
4. 파일 경로는 반드시 정규화 후 사용 (path traversal 방지)
5. SQL은 반드시 파라미터화된 쿼리 사용 (ORM 사용 권장)
6. CORS는 반드시 명시적 오리진 지정
7. 새로운 의존성 추가 시 반드시 사람의 승인 필요
```

---

## 9. 성능 최적화 전략

### 9.1 토큰 효율성

AI API 호출 비용과 속도를 최적화하기 위한 전략.

**모델 계층화:** 모든 작업에 최고 성능 모델을 사용할 필요는 없다.

|작업 유형|권장 모델 계층|이유|
|---|---|---|
|아키텍처 설계|최상위 (Opus)|복잡한 추론 필요|
|기능 구현|중상위 (Sonnet)|균형잡힌 품질/속도|
|코드 리뷰|중상위 (Sonnet)|패턴 인식 중심|
|리팩토링|중간 (Sonnet/Haiku)|패턴 변환 중심|
|보일러플레이트|하위 (Haiku)|단순 패턴 반복|
|코드 포매팅|도구 (Prettier)|AI 불필요|

**캐싱 전략:**

- 시스템 프롬프트와 프로젝트 컨텍스트는 프롬프트 캐싱을 활용
- 동일한 패턴의 코드 생성 요청은 이전 결과를 템플릿으로 재활용
- 코드 리뷰 결과를 누적해서 "자주 발생하는 문제" 목록으로 관리

### 9.2 병렬 생성

독립적인 모듈은 병렬로 생성할 수 있다.

```
의존성 그래프 분석:
  모듈A (독립) ─┐
  모듈B (독립) ─┼→ 병렬 생성 가능
  모듈C (독립) ─┘
  
  모듈D (A에 의존) → A 완료 후 순차 생성
  모듈E (B, C에 의존) → B, C 완료 후 순차 생성
```

### 9.3 점진적 생성 vs 일괄 생성

**점진적 생성 (Incremental):**

- 작은 단위로 생성 → 검증 → 다음 단위
- 장점: 오류를 일찍 발견, 디버깅 용이
- 단점: 전체 설계의 일관성 유지가 어려울 수 있음
- 적합한 경우: 기존 코드베이스에 기능 추가

**일괄 생성 (Batch):**

- 전체 설계를 한 번에 생성
- 장점: 전체적 일관성 보장
- 단점: 오류 발생 시 전체 재생성 필요
- 적합한 경우: 새 프로젝트 스캐폴딩, 독립적 유틸리티 모듈

---

## 10. 실전 워크플로우

### 10.1 그린필드 프로젝트 워크플로우

새 프로젝트를 AI와 함께 시작할 때의 워크플로우.

```
Phase 1: 기반 설정 (1회)
├── 기술 스택 결정 및 문서화
├── 프로젝트 스캐폴딩 생성
├── CLAUDE.md / 규칙 파일 작성
├── 핵심 타입 정의
├── 기본 인프라 코드 (DB 연결, API 클라이언트)
└── CI/CD 파이프라인 설정

Phase 2: 기능 구현 (반복)
├── 기능 분해 → 태스크 목록
├── 각 태스크:
│   ├── 인터페이스 먼저 정의
│   ├── 테스트 케이스 생성
│   ├── 구현 코드 생성
│   ├── 검증 (자동 + 수동)
│   └── Git 커밋
└── 기능 통합 테스트

Phase 3: 안정화 (주기적)
├── 코드 리뷰 (AI 리뷰어 + 사람)
├── 리팩토링
├── 문서 갱신
└── 성능 프로파일링
```

### 10.2 레거시 코드 현대화 워크플로우

기존 코드베이스를 AI와 함께 개선할 때의 워크플로우.

```
Phase 1: 이해 (읽기 전용)
├── AI에게 코드베이스 구조를 분석하게 함
├── 의존성 그래프 시각화
├── 기술 부채 목록 작성
└── 위험 영역 식별

Phase 2: 안전망 구축
├── 기존 동작을 캡처하는 통합 테스트 작성 (characterization tests)
├── 핵심 비즈니스 로직의 단위 테스트 보강
└── CI에서 테스트 자동 실행 설정

Phase 3: 점진적 개선
├── 가장 영향도 높고 위험도 낮은 영역부터
├── 모듈 단위로 리팩토링
├── 매 변경마다 기존 테스트 통과 확인
└── 새로운 패턴으로 작성된 코드가 "참고 예시"가 됨
```

### 10.3 일상적 개발 루프

매일의 개발 작업에서 AI를 활용하는 패턴.

```
1. 작업 시작
   └── "오늘 구현할 기능은 X다. 관련 코드를 읽고 구현 계획을 세워줘"

2. 구현
   └── 계획을 단계별로 실행, 각 단계마다 검증

3. 문제 해결
   └── 에러 발생 시: 에러 메시지 + 관련 코드 + 시도한 것을 구조화해서 전달

4. 리뷰
   └── "방금 작성한 코드를 리뷰해줘. 특히 [보안/성능/가독성]을 중점적으로"

5. 정리
   └── 커밋 메시지 생성, 변경 사항 문서화, 남은 작업 정리
```

---

## 11. 안티패턴

### 11.1 피해야 할 패턴들

**"AI한테 다 맡기자" 증후군:** AI에게 모든 의사결정을 위임하면 프로젝트의 방향성이 없어진다. AI는 구현 도구이지, 제품 오너나 아키텍트가 아니다. 기술적 의사결정의 최종 책임은 항상 사람에게 있다.

**프롬프트 만능주의:** 복잡한 문제를 하나의 완벽한 프롬프트로 해결하려는 시도. 실제로는 반복적 대화와 점진적 정제가 더 효과적이다.

**검증 없는 통합:** AI가 생성한 코드를 읽지도 않고 바로 커밋하는 행위. AI가 생성한 모든 코드는 "초안"이며, 반드시 사람의 검토를 거쳐야 한다.

**컨텍스트 과적:** 컨텍스트 윈도우에 가능한 모든 정보를 넣으려는 시도. 정보가 너무 많으면 오히려 핵심을 놓치고, 출력 품질이 저하된다.

**단일 세션 집착:** 하나의 대화 세션에서 모든 것을 해결하려는 시도. 컨텍스트가 오염되면 새 세션을 시작하고, 핵심 결정사항만 가져가는 것이 더 효율적이다.

---

## 12. 미래 전망과 준비

### 12.1 단기 진화 방향 (1-2년)

- **컨텍스트 윈도우 확대:** 프로젝트 전체를 컨텍스트에 넣을 수 있게 되면 컨텍스트 선택 전략의 중요성이 줄어든다. 하지만 "무엇에 주의를 기울일 것인가"의 문제는 여전히 남는다.
- **도구 사용 능력 향상:** AI가 직접 파일을 읽고, 테스트를 실행하고, 빌드를 돌리는 에이전틱 워크플로우가 표준이 된다.
- **코드 리뷰 자동화:** AI 리뷰어가 보안 취약점, 성능 이슈, 컨벤션 위반을 자동으로 감지하고 수정안을 제안한다.

### 12.2 중기 진화 방향 (3-5년)

- **자율 디버깅:** 에러 발생 시 AI가 자율적으로 원인을 분석하고 수정하는 루프가 안정화된다.
- **명세 기반 생성:** 자연어 명세에서 직접 프로덕션 코드를 생성하는 것이 일반적인 워크플로우가 된다.
- **개인화된 코드 생성:** 개발자의 코딩 스타일, 선호하는 패턴, 과거 결정을 학습해서 점점 더 그 개발자답게 코드를 생성한다.

### 12.3 변하지 않는 것

기술이 아무리 발전해도 변하지 않는 원칙들:

- **명확한 요구사항의 가치:** AI가 아무리 똑똑해져도, 무엇을 만들어야 하는지 모르면 아무것도 만들 수 없다.
- **아키텍처적 사고의 중요성:** 코드 생성이 자동화될수록, 시스템을 설계하고 제약을 정의하는 능력이 더 중요해진다.
- **코드 리뷰의 필요성:** AI가 생성한 코드라도 사람이 이해하고 유지보수해야 한다. 코드를 읽는 능력은 코드를 쓰는 능력보다 오래 중요할 것이다.
- **테스트의 역할:** 자동 생성된 코드일수록 자동화된 검증이 필수적이다. 테스트는 AI 시대에 더 중요해진다, 덜 중요해지지 않는다.

---

## 부록 A: 체크리스트

### AI 코드 생성 프로젝트 시작 체크리스트

- [ ] 기술 스택이 문서화되어 있는가?
- [ ] CLAUDE.md / 규칙 파일이 작성되어 있는가?
- [ ] 디렉토리 구조가 일관되고 AI 친화적인가?
- [ ] 핵심 타입과 인터페이스가 정의되어 있는가?
- [ ] 코딩 컨벤션이 명문화되어 있는가?
- [ ] 자동 검증 파이프라인(린트, 타입체크, 테스트)이 설정되어 있는가?
- [ ] 참고할 만한 "골든 예시" 코드가 있는가?
- [ ] 보안 가드레일이 정의되어 있는가?

### AI 생성 코드 리뷰 체크리스트

- [ ] 원래 의도한 기능을 정확히 수행하는가?
- [ ] 타입 안전성이 보장되는가?
- [ ] 에러 핸들링이 적절한가?
- [ ] 보안 취약점이 없는가? (입력 검증, 인젝션 방지)
- [ ] 불필요한 복잡성이 없는가?
- [ ] 기존 코드 패턴과 일관성이 있는가?
- [ ] 테스트가 동반되었는가?
- [ ] 하드코딩된 값이 없는가?
- [ ] 존재하지 않는 API를 호출하지 않는가?

---

## 부록 B: 용어 정리

|용어|정의|
|---|---|
|컨텍스트 윈도우|AI 모델이 한 번에 처리할 수 있는 입출력 텍스트의 최대 크기|
|프롬프트 캐싱|반복되는 프롬프트 접두사를 캐시해서 비용과 지연을 줄이는 기술|
|RAG|Retrieval-Augmented Generation. 외부 지식을 검색해서 생성에 활용하는 패턴|
|에이전틱 워크플로우|AI가 도구를 사용해 자율적으로 작업을 수행하는 워크플로우|
|가드레일|AI의 행동을 제한하는 규칙이나 메커니즘|
|환각|AI가 사실이 아닌 정보를 자신있게 생성하는 현상|
|컨텍스트 드리프트|긴 대화에서 초기 맥락을 점차 잊어가는 현상|
|메타 프롬프팅|AI의 행동 방식 자체를 지시하는 상위 수준의 프롬프트 기법|
|GSD|Get Shit Done. 체계적 질문과 계획을 통해 AI 코드 생성을 구조화하는 메타 프롬프팅 시스템|